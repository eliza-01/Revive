on_update({"hp_ratio": None, "ts": time.time()}) — это вызов колбэка из движка player_state, которым он сообщает наверх:

hp_ratio=None → «значение HP неизвестно» (мы раньше использовали это, чтобы HUD показал --),

ts → отметка времени события.

Почему убираем:

Разделяем роли. Теперь политики UI (маскирование/восстановление виталов) управляет PlayerStateService по флагам paused/pause_reason. Движок — только «сенсор», без решений про UI.

Избегаем двойных эффектов. Если и движок, и сервис будут маскировать, получим гонки/мигание HUD и непредсказуемый порядок обновлений.

Единая точка логики пауз. Все причины паузы (не только unfocused) обрабатываются в одном месте — в сервисе. Движок просто приостанавливает измерения на паузе.

Меньше связности. Движок больше не «знает» про то, что надо триггерить маску — он стабильно публикует только измеренные значения, когда не на паузе.

Итог: при паузе сервис сам ставит HUD на -- и чистит виталы в пуле; при снятии паузы HUD возвращается в норму по очередному реальному значению от движка.
_
Проблема и решение
Что происходит:

Основной замер иногда даёт < 0.01 (из-за шума/мигания/перекрытий/смещения зоны).

probe_now() видит хоть столбец «живого» цвета → обновляет last_alive_seen_ts.

В течение 1.5 c после этого каждый тик при hp_ratio < 0.01 шлётся fallback_alive=True.

В _on_ps_update() на это ты маскируешь виталы: alive=True, hp_ratio=None.

У координатора условие alive=True & hp=None & autofarm.busy=True включает cor_2 → запускается ui_guard; потом всё повторяется, отсюда «карусель» отчётов.

Почему это может «мигать» даже на полном HP:

Порог ровно 0.01 без гистерезиса: достаточно одного (шумного) тика ниже 1% → включили эвристику.

probe_now() считает «живые» колонки по любому попаданию цвета (без морфологии/минимальной длины пробега), поэтому легко ловит ложные «живые» пиксели.

learn() мог выучить слишком широкую/смещённую bar_rect и захватывать соседние элементы UI подходящего цвета.

Что сделать (в порядке безболезненности):

Диагностика (быстро добавить логи)

В start() сразу после вычисления hp_ratio логируй редкие события:

hp_ratio<0.02 (чтобы понять, как часто проваливается ниже порога).

факты входа в ветку fallback_alive (с таймштампом и значением fb_val).

В _HPFallbackTracker.probe_now() логируй alive/total (или хотя бы alive) если alive>0 при основном <0.01 — поймёшь, шум это или реальный сигнал.

Одновременно в _on_ps_update() (PS-сервис) логируй приход fallback_alive=True и текущее features.autofarm.busy.

Смягчить включение fallback_alive (антишум/дебаунс)

Ввести гистерезис для основного порога:
LOW = 0.01, HIGH = 0.03.
Переключаться в «низкое» состояние только если hp_ratio <= LOW несколько тиков подряд (например, 3 тика), и выходить из него лишь когда hp_ratio >= HIGH. Это уберёт дрожание на границе.

Перед тем как слать fallback_alive=True, требовать N подряд низких тиков (например, 3) + «живые» столбцы в фолбэке. Одного «плохого» тика — недостаточно.

Урезать ложные срабатывания в фолбэке

В probe_now() считать не «любой пиксель в колонке», а непрерывный горизонтальный пробег (минимальная длина, например ≥ 3 px) или минимальную долю «живых» в колонке. Сейчас достаточно одного пикселя нужного цвета, что очень шумно.

Добавить лёгкую морфологию к маске фолбэка (как в основном методе делается morph close), чтобы склеивать крошечные шумовые точки.

В learn() валидировать bar_rect:

учить не на единственном hp==1.0, а на 2–3 подряд тиках;

отбрасывать слишком высокие или широкие прямоугольники (санити-чек по ожидаемым размерам полосы).

Быстрый «предохранитель» против cor_2 (если надо прямо сейчас уменьшить дёрганье координатора)

В _on_ps_update() вместо «прятать HP» при fallback_alive можно оставлять последний валидный hp_ratio (или маленькую, но ненулевую константу, например 0.02) и alive=True. Тогда условие cor_2 не выполнится (там требуется именно hp=None). Это поведение менее «строгое» (мы не сигналим, что HP неизвестен), но резко снизит ложные старты ui_guard.

Альтернатива: сложить флаг в пул player.flags.fallback_alive=True и поменять Cor2Reason, чтобы игнорировать hp=None, если флаг активен последние, скажем, 2 секунды.

Куда смотреть дальше, если окажется, что основной замер гуляет:

Параметры DEFAULT_HP_PROBE_RGB / DEFAULT_HP_COLOR_TOL — завышенная толерантность или неправильный оттенок.

Геометрию захвата зоны DEFAULT_ZONE_* и _compute_center_bottom_zone_ltrb() — при другом масштабе/окне могла поехать.

Перекрытия (dashboard/Alt+B/языковая плашка) — но тут ты уже подчистил репорты ui_guard, так что будет видно по логам.

Хочешь — скажу «точечные» места для вставок логов и минимальные изменения на дебаунс/гистерезис без ломки интерфейса (буквально 10–15 строк в start() и probe_now()).