--- a/app/launcher_html.py
+++ b/app/launcher_html.py
@@
-from __future__ import annotations
-import queue
-import os, importlib, threading, time
+from __future__ import annotations
+import os, importlib, threading, time
 import webview
@@
-from core.vision.matching.template_matcher import match_in_zone
-
-def _safe_import(modpath: str):
+def _safe_import(modpath: str):
     try:
         return importlib.import_module(modpath)
     except Exception:
         return None
@@
-class Repeater:
+class Repeater:
     def __init__(self, fn, interval_s: float):
         self.fn = fn; self.interval = max(0.05, float(interval_s))
         self._stop = threading.Event(); self._thr = None
@@
-            self._stop.wait(self.interval)
-
-
-class _CheckerShim:
-    def __init__(self, checker): self.c = checker
-    def is_charged(self, *_):
-        try: return self.c.force_check()
-        except: return None
-    def force_check(self, *_):
-        try: return self.c.force_check()
-        except: return None
-    def invalidate(self):
-        try: self.c.invalidate()
-        except: pass
+            self._stop.wait(self.interval)
@@
 class Bridge:
     def __init__(self, version: str):
         self.version = version
@@
-        self._tp_zones = {}
-        self._tp_tpls = {}
-        self._load_tp_cfg()
-
         # ---- железо
         self.controller = ReviveController()
@@
-        # простой планировщик "как root.after"
-        def schedule(fn, ms): threading.Timer(max(0, ms) / 1000.0, fn).start()
-
-        class _SerialScheduler:
-            def __init__(self):
-                self._q = queue.Queue()
-                self._thr = threading.Thread(target=self._pump, daemon=True)
-                self._thr.start()
-            def _pump(self):
-                while True:
-                    fn = self._q.get()
-                    try: fn()
-                    finally: self._q.task_done()
-            def after(self, ms, fn):
-                threading.Timer(max(0, ms)/1000.0, lambda: self._q.put(fn)).start()
-
-        _sched = _SerialScheduler()
-        def schedule(fn, ms): _sched.after(ms, fn)
+        # простой планировщик — как в старом UI (root.after)
+        def schedule(fn, ms): threading.Timer(max(0, ms) / 1000.0, fn).start()

         self.orch = FlowOrchestrator(
             schedule=schedule,
             log=print,
-            checker=_CheckerShim(self.checker),
+            checker=self.checker,              # ← как в старом UI
             watcher=self.watcher,
             to_village=self.to_village,
             postrow_runner=self.postrow,
             restart_manager=self.restart,
             get_server=lambda: self.server,
             get_language=lambda: self.language,
         )
@@
-        # ---- передаём «виджеты» в оркестратор (как в старом UI)
+        # ---- передаём «виджеты» в оркестратор (точно как в старом UI)
         self.orch.set_ui(
             buff_is_enabled=lambda: self._buff_enabled,
             buff_run_once=lambda: self._buff_run_once(),
             macros_ui_is_enabled=lambda: self._macros_enabled,
             macros_ui_run_always=lambda: self._macros_run_always,
             macros_ui_get_duration_s=lambda: self._macros_duration_s,
             macros_run_once=lambda: self._macros_runner.run_once(),
-            tp_is_enabled=lambda: self._tp_enabled,  # ← НЕ через cat/loc
+            tp_is_enabled=lambda: self._tp_enabled,   # только флаг, как TPControls.is_enabled()
             tp_teleport_now_selected=lambda: self._tp_teleport_now_selected(),
             tp_get_selected_destination=lambda: (self._tp_cfg["cat"], self._tp_cfg["loc"]),
             tp_get_selected_row_id=lambda: self._selected_row_id,
             respawn_ui_is_enabled=lambda: True,
         )
@@
-    def set_server(self, server: str):
-        self._load_tp_cfg()
+    def set_server(self, server: str):
         self.server = (server or "l2mad").lower()
         self.profile = get_server_profile(self.server)
@@
-    def _wait_for_charged(self, timeout_s: float = 12.0, poll_s: float = 0.5) -> bool:
+    def _wait_for_charged(self, timeout_s: float = 12.0, poll_s: float = 0.5) -> bool:
         """После бафа активно ждём появления иконок."""
         try: self.checker.invalidate()
         except Exception: pass
         t0 = time.time(); val = None
         while time.time() - t0 < timeout_s:
             try: val = self.checker.force_check()
             except Exception: val = None
             if val is True: return True
             time.sleep(poll_s)
         return bool(val)
@@
-        worker = BuffAfterRespawnWorker(
-            self.controller,           # controller
-            self.server,               # server
-            lambda: self._window_info, # get_window
-            lambda: self.language,     # get_language
-            lambda m, ok=None: print(m),  # on_status
-            0.87,                      # click_threshold
-            False,                     # debug
-        )
+        worker = BuffAfterRespawnWorker(
+            controller=self.controller,
+            server=self.server,
+            get_window=lambda: self._window_info,
+            get_language=lambda: self.language,
+            on_status=lambda m, ok=None: print(m),
+            click_threshold=0.87,
+            debug=False,
+        )
@@
-        ok = self._buff_run_once()
-        try: charged = self.checker.force_check()
-        except Exception: charged = None
-        return {"ok": ok, "charged": charged}
+        ok = self._buff_run_once()
+        try:
+            charged = self.checker.force_check()
+        except Exception:
+            charged = None
+        return {"ok": ok, "charged": charged}
@@
-        # точь-в-точь логика старого UI: пользователь сохранил цель → ТП считается включённым
+        # как в старом UI: пользователь включил тумблер ТП + выбрана цель
         self._tp_enabled = bool(self._tp_cfg["cat"] and self._tp_cfg["loc"])
@@
-        # 1) освежить окно (как старый UI)
-        try:
-            self.get_window()  # обновит self._window_info, автостарт watcher — ок
-        except Exception:
-            pass
-        try:
-            self.tp_worker.window_info = self._window_info
-        except Exception:
-            pass
-
-        # 2) привести дэш к консистентному состоянию: если открыт — закрыть,
-        #    чтобы воркер не «перекликал» (b→закрыть вместо открыть)
-        self._pre_tp_normalize_dashboard()
-
-        # 3) запустить ТП
+        # как в старом UI: просто обновить окно и дернуть воркер
+        try: self.get_window()
+        except Exception: pass
+        try: self.tp_worker.window_info = self._window_info
+        except Exception: pass
         return bool(self.tp_worker.teleport_now(
             self._tp_cfg["cat"], self._tp_cfg["loc"], self._tp_cfg["method"]
         ))
